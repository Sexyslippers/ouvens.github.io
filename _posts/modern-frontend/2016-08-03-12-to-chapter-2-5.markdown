---
layout: post
title:  "现代前端体系-第二章 5-Native交互协议"
date:  2016-08-02
author: ouven
tags: 现代前端体系 5-Native交互协议
categories: modern-frontend
cover: "assets/category/type-javascript.png"
---

### 第二章 5-Native交互协议

&emsp;&emsp;智能移动设备出现后，移动端native开发显示出井喷的趋势。原生应用开发很快得到一批掘金者的追捧，相比于之前wap web应用的简单网页开发，native app以更好的性能，开发体验以及google、apple开发商的支持引领了移动互联网时代的第一波浪潮。更随之而来的就是HTML5的出现。让移动开发进入native app、web pp、hybrid app并存的时代(当然现在人们也提出bybrid app和native app之间折中的一层)。随着移动互联网第一波浪潮的过去，bybrid app结合了native app和web app的优势，适应了更多的移动应用场景，成为目前广为使用的开发模式。当然native app和web app今天依然有它们适用的场景。

&emsp;&emsp;提到hybrid app，相比于传统的PC端web app，它具有系统网络可用资源更少、支持更新的浏览器特性和api、可移动离线使用、支持与原生交互等几个方面不同支持。这节我们先来看看Hybrid App的交互性协议。


#### 2.5.1 H5调用native协议

&emsp;&emsp;首先看下使用Hybrid App的Javascript调用一个Native的方法或界面的协议。其原理如下，native应用可向移动端系统主持一个scheme协议uri，这个url可在系统中任意地方授权访问来调起一段原生方法或原生的一个界面控件。同样，native的webview控件中的js也可以授权调用这一通用scheme协议。一般通过window.location.href赋值或发送iframe的方式掉native注册的jsbridge桥协议。例如

```
var ifr = document.createElement("iframe");
ifr.setAttribute('style', 'display:none');
document.body.appendChild(ifr);
ifr.setAttribute('src', 'myApp://namespace/method?args');
```

此时，webview会将获取uri资源的地址交给系统，系统接收并进行解析，如果你的native应用注册了相关的scheme uri到系统广播。系统则就通过此uri地址执行app注册的指令，执行一段代码或者拉起app的某个界面(例如打开摄像头、呼起app首页等等)。从而完成H5向native的调用。

#### 2.5.2 native调用H5协议
    
&emsp;&emsp;相反，native如果需要主动调用H5中JavaScript的方法或指令。也需要先使用JavaScript申明相对应的方法。其中native想H5发起的调用是通过loadUrl(android下面方法名为loadUrl，ios也有相应的方法来实现)方法来发起的。

- native可以通过loadUrl方法调用页面中某个技术方法，例如 `webview.loadUrl("javascript: alert('hello world')");`
- 另外native可以通过addJavascriptInterface将native的一个对象方法注入到页面中供页面中的js调用

```
WebSettings webSettings = webView.getSettings();
 
webSettings.setJavaScriptEnabled(true);

webView.addJavascriptInterface(new JsInterface(), "control");
 
public class JsInterface {
 
        @JavascriptInterface
        public void showToast(String toast) {
            Toast.makeText(MainActivity.this, toast, Toast.LENGTH_SHORT).show();
            log("show toast success");
        }
 
        public void log(final String msg){
            webView.post(new Runnable() {
                @Override
                public void run() {
                	// 这里log是js的log方法
                    webView.loadUrl("javascript: log(" + "'" + msg + "'" + ")");
                }
            });
        }
    }
```

可以看到这个interface我们给它取名叫control。

最后loadUrl。

```
webView.loadUrl("file:///android_asset/interact.html");
```

好了，让我们再看看js脚本中的那个showToast()方法。

```
function showToast(toast) {
            javascript:control.showToast(toast);
        }
```

这里的control就是我们的那个interface，调用了interface的showToast方法

```
@JavascriptInterface
public void showToast(String toast) {
    Toast.makeText(MainActivity.this, toast, Toast.LENGTH_SHORT).show();
    log("show toast success");
}
```

可以看到先显示一个toast，然后调用log()方法，log()方法里调用了js脚本的log()方法。

```
function log(msg){
    console.log(msg);
}
```

js的log()方法做的事就是在控制台输出msg。


### 2.5.3 JSBridge

&emsp;&emsp;似乎已经没有问题了，但了解Android的人应该知道(笔者以前做过一段时间Android开发，又来专门也去查了下)，使用addJavaScriptInterface载Android4.2以下有安全漏洞，即通过JavaScript，可以访问当前设备的SD卡上面的任何东西，甚至是联系人信息，短信等。这就不大合理了。我们的预期是js仅仅用来实现H5与native的交互通信的。那我们尽量的采用另一个方案来处理，另外关于通讯协议本身也需要更加规范。

通常我们这样定义H5与native之间的协议串(这里我们一Android系统为例)`jsbridge://className:callbackMethod/methodName?jsonObj`，至于为什么这样定义，当然也可以使用其它的方式，这里只是一种方法。这里jsbridge是native向低筒注册的协议头，className对应的native的类，methodName指调用native类的具体哪个方法，jsonObj则是H5调用Native方法传过去的参数，callbackMethod带有的是H5的回调方法，目的是在H5调用native的方法成功后异步通过`loadUrl('javascript: callbackMethod()')`来让H5继续做成功后的操作。

假设我们需要调用native层的Logger类的log方法，当然这个类以及方法肯定是遵循某种规范的，不是所有的java类都可以调用，不然就跟文章开头的WebView漏洞一样了，参数是msg，执行完成后js层要有一个回调，那么地址就如下。

例如下面则表示H5调用native的Util类中的toStirng方法，传入的参数是`{"msg":"this is string"}`，调用成功后执行callback函数。

```
jsbridge://Util:callback/toString?{"msg":"this is string"}
```

&emsp;&emsp;通常为了方便管理，较多的类花费方法，通常使用一个通用注册方法来注册我们可能需要使用到类和方法，`JSBridge.register("jsName",javaClass.class)`，执行时可以使用`JSBridge.call(className,methodName,params,callback)`，执行call将参数组装成`jsbridge://className:callbackMethod/methodName?jsonObj`的形式，然后调用iframe(io一般用iframe，Android有人用window.promot，但统一起见使用iframe即可)的方法将uri传递过去`window.promot(uri, '')`，这时候java层就会收到这个uri，再进一步解析即可。

&emsp;&emsp;OK，实现的原理就这么多。IOS的原理基本类似，只是形式不同。例如ios Native调用Javascript语言，是通过UIWebView组件的stringByEvaluatingJavaScriptFromString方法来实现的，该方法返回js脚本的执行结果，Android使用的是loadUrl。

